# Function required to make rest of code run

BMsim <- function(x0, t, iters){
  vec <- numeric(iters)
  vec[1] <- sqrt(x0)
  dt <- t/iters
  time <- seq(0, t, length.out = iters)
  for(i in 2:iters){
    xt <- rnorm(1, 0, 1)
    vec[i]<- vec[i-1] + sqrt(dt) * xt
  }
  return(list(vec, time))
}

GBMsim <- function(mu, sigma, x0, t, iters){
  dt <- t/iters
  vec <- numeric(iters)
  vec[1] <- x0
  for(i in  2:iters){
    xs <- vec[i-1]
    xt <- rlnorm(1, (log(xs) + (mu-sigma^2/2)*dt), sigma*sqrt(dt))
    #xy <- rnorm(1, 0, sqrt(dt))
    #xt <- xs * exp((mu-0.5*sigma^2)*dt + sigma*xy)
    vec[i] <- xt
  }
  return(vec)
}


GBMsimEM <- function(mu, sigma, x0, t, iters){
  dt <- t/iters
  vec <- numeric(iters)
  vec[1] <- x0
  for(i in  2:iters){
    xs <- vec[i-1]
    xt <-  rnorm(1, xs + mu*xs*dt, sqrt(sigma^2*xs^2*dt))
    if(xt <= 0.0001){
      xt <- 0.0001
    }
    vec[i] <- xt
  }
  return(vec)
}




# Code for Figure 2.1

simulate_GBM_vs_ODE <- function(mu, sigma, x0, t, iters, seed) {
  set.seed(seed)
  dt <- t / iters
  time <- seq(0, t, length.out = iters + 1)
  gbm <- numeric(length(time))
  gbm[1] <- x0
  for (i in 2:length(time)) {
    z <- rnorm(1)
    gbm[i] <- gbm[i - 1] * exp((mu - 0.5 * sigma^2) * dt + sigma * sqrt(dt) * z)
  }
  ode <- x0 * exp(mu * time)
  return(list(time = time, gbm = gbm, ode = ode))
}

result <- simulate_GBM_vs_ODE(mu = 0.05, sigma = 0.2, x0 = 1, t = 25, iters = 1000, seed = 5)

plot(result$time, result$gbm, type = "l", col = "blue", lwd = 2,
     ylim = range(c(result$gbm, result$ode)),
     main = "Geometric Brownian Motion vs ODE",
     xlab = "Time", ylab = expression(W[t]), las = 1)
lines(result$time, result$ode, col = "red", lwd = 2, lty = 2)
legend("topleft", legend = c("GBM (stochastic)", "ODE (deterministic)"),
       col = c("blue", "red"), lwd = 2, lty = c(1, 2))





# Code for Figure 2.2

par(mfrow = c(1,1))

set.seed(6)
sims <- BMsim(0, 9, 1000)
sims[[1]]
plot(ts(sims[[1]], deltat = 0.01, start = 0), ylim = c(-4, 8), main = 'Brownian Motion', 
     ylab = expression(W[t]), xlab = 'time', xlim = c(0, 10), cex.main = 0.75)
for(i in 1:2){
  set.seed(i+1)
  sims <- BMsim(0, 9, 1000)
  lines(ts(sims[[1]], deltat = 0.01, start = 0))
}




# Code for Figure 2.3

simulate_GBM_vs_ODE <- function(mu, sigma, x0, t, iters, seed) {
  set.seed(seed)
  dt <- t / iters
  time <- seq(0, t, length.out = iters + 1)
  gbm <- numeric(length(time))
  gbm[1] <- x0
  for (i in 2:length(time)) {
    z <- rnorm(1)
    gbm[i] <- gbm[i - 1] * exp((mu - 0.5 * sigma^2) * dt + sigma * sqrt(dt) * z)
  }
  ode <- x0 * exp(mu * time)
  return(list(time = time, gbm = gbm, ode = ode))
}

result <- simulate_GBM_vs_ODE(mu = 0.05, sigma = 0.2, x0 = 1, t = 25, iters = 1000, seed = 5)

plot(result$time, result$gbm, type = "l", col = "blue", lwd = 2,
     ylim = range(c(result$gbm, result$ode)),
     main = "Geometric Brownian Motion vs ODE",
     xlab = "Time", ylab = expression(W[t]), las = 1)
lines(result$time, result$ode, col = "red", lwd = 2, lty = 2)
legend("topleft", legend = c("GBM (stochastic)", "ODE (deterministic)"),
       col = c("blue", "red"), lwd = 2, lty = c(1, 2))





# Figure 3.1


library(ggplot2)
library(MASS)

#Function to generate synthetic paths

generate_latent_chain <- function(known_states, observation_times, theta, dt, n_paths) {
  path_segments <- list()
  for (i in 1:(length(observation_times) - 1)) {
    start_state <- known_states[i, ]
    end_state <- known_states[i + 1, ]
    duration <- observation_times[i + 1] - observation_times[i]
    time_grid <- seq(observation_times[i], observation_times[i + 1], by = dt)
    
    segment_paths <- replicate(n_paths, {
      sim <- DGBmulti(start_state, end_state, theta, duration, dt)
      sim[, 1]  
    })

    segment_df <- data.frame(
      time = rep(time_grid, n_paths),
      value = as.vector(segment_paths),
      path_id = rep(1:n_paths, each = length(time_grid))
    )
    path_segments[[i]] <- segment_df
  }
  full_paths <- do.call(rbind, path_segments)
  return(full_paths)
}

#Generate data to simulate draws

beta <- function(x, theta) {
  matrix(c(1, 0, 0, 1), nrow = 2)
}

observed_states <- matrix(c(
  2, 2,
  3, 4,
  5, 6,
  10, 10,
  20, 14
), ncol = 2, byrow = TRUE)

observation_times <- c(0, 0.5, 1, 1.5, 2)
theta <- c(0.5, 0.0025, 0.3)
dt <- 0.1
n_paths <- 10

latent_paths <- generate_latent_chain(observed_states, observation_times, theta, dt, n_paths)

observed_df <- data.frame(
  time = observation_times,
  value = observed_states[, 1]  
)

ggplot() +
  geom_line(data = latent_paths, aes(x = time, y = value, group = path_id, color = as.factor(path_id)), alpha = 0.7) +
  geom_point(data = observed_df, aes(x = time, y = value), color = "red", size = 3) +
  labs(x = "Time", y = "State", title = "Latent Path Simulation Between Observations") +
  theme_minimal() +
  theme(legend.position = "none")





#Figure 5.1

set.seed(1)
PMMH_results_initial12 <- PMMH_bridge_multi(c(0.9, 0.05, 0.7), out3, 1, 0.05, 30, 10000, 
                                           matrix(c(0.001, 0, 0, 0, 0.00001, 0, 0, 0, 0.001), nrow = 3))

PMMH_tune12 <- var(PMMH_results_initial12[[1]][1000:10000,])

set.seed(1)
PMMH_results_tune12 <- PMMH_bridge_multi(c(0.9, 0.05, 0.7), out3, 1, 0.05, 30, 10000, 
                                        PMMH_tune12*(2.562)^2/3)

tsplot(PMMH_results_tune12[[1]][5400:10000,1], xlab = 'Iterations', ylab = expression(theta[1]))
tsplot(PMMH_results_tune12[[1]][5400:10000,2], xlab = 'Iterations', ylab = expression(theta[2]))
tsplot(PMMH_results_tune12[[1]][5400:10000,3], xlab = 'Iterations', ylab = expression(theta[3]))




#Figure 5.2

set.seed(3)
Gibbs_results_initial2 <- Gibbs(out3, c(0.9, 0.05, 0.7), matrix(c(0.001, 0, 0, 0, 0.00001, 0, 0, 0, 0.001), nrow = 3),
                                1, 0.05, 10000)

Gibbs_tune2 <- var(Gibbs_results_initial2[[1]])

set.seed(3)
Gibbs_results_tune2 <- Gibbs(out3, c(0.9, 0.05, 0.7), Gibbs_tune2*(2.38)^2/3, 1, 0.05, 10000)

tsplot(Gibbs_results_tune2[[1]][100:10000,1], xlab = 'Iterations', ylab = expression(theta[1]))
tsplot(Gibbs_results_tune2[[1]][100:10000,2], xlab = 'Iterations', ylab = expression(theta[2]))
tsplot(Gibbs_results_tune2[[1]][100:10000,3], xlab = 'Iterations', ylab = expression(theta[3]))
